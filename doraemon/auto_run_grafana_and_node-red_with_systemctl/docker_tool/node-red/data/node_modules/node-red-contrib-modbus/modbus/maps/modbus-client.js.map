{"version":3,"sources":["modbus-client.js"],"names":["module","exports","RED","require","install","coreModbusClient","coreModbusQueue","node","registerType","setStoppedState","config","nodes","createNode","this","serialConnectionDelayTimeMS","unlimitedListeners","defaultUnitId","clienttype","undefined","timeoutTimeMS","logHintText","bufferCommands","parallelUnitIdsAllowed","stateLogEnabled","tcpHost","tcpPort","parseInt","tcpType","serialBaudrate","serialStopbits","serialPort","serialDatabits","serialConnectionDelay","serialAsciiResponseStartDelimiter","serialType","unit_id","reconnectTimeout","commandDelay","reconnectOnTimeout","verboseWarn","logMessage","serverInfo","verbose","warn","settings","internalDebug","isFirstInitOfConnection","closingModbus","Map","client","bufferCommandList","messagesAllowedStates","sendingAllowed","messageAllowedStates","stateMachine","createStateMachineService","stateService","initialState","actualServiceState","actualServiceStateBefore","reconnectTimeoutId","internalDebugLog","setDefaultUnitId","ModbusClientNode","setUnitIdFromPayload","msg","getActualUnitId","unitId","checkUnitId","verboseLog","queueLogEnabled","state","value","matches","updateServerinfo","initQueue","setTimeout","connectClient","err","payload","emit","queueSerialUnlockCommand","send","serialSendingAllowed","queueSerialLockCommand","close","message","ModbusRTU","clientTimeout","error","Error","connectC701","port","setTCPConnected","modbusTcpErrorHandling","connectTelnet","autoOpen","setTCPConnectionOptions","connectTcpRTUBuffered","connectTCP","serialPortOptions","baudRate","dataBits","stopBits","startOfSlaveFrameChar","toString","connectAsciiSerial","then","setSerialConnectionOptions","modbusSerialErrorHandling","serialParity","setID","connectRTU","modbusSerialDebug","openSerialClient","JSON","stringify","errno","networkErrors","includes","modbusErrorHandling","code","showErrors","_port","on","onModbusClose","cb","cberr","indexOf","pushToQueueByUnitId","queueLength","get","queueUnitId","length","readModbus","info","writeModbus","queueLog","activateSending","checkQueuesAreEmpty","reject","Promise","mbBasics","invalidPayloadIn","setNewNodeSettings","setMaxListeners","done","nodeIdentifierName","name","removeAllListeners","isOpen","registeredNodeList","registerForModbus","clientUserNodeId","Object","keys","deregisterForModbus","httpAdmin","auth","needsPermission","req","res","json","ports"],"mappings":"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","file":"../modbus-client.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus connection node.\n * @module NodeRedModbusClient\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusClient = require('./core/modbus-client-core')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n  const internalDebugLog = require('debug')('contribModbus:config:client')\n\n  function ModbusClientNode (config) {\n    RED.nodes.createNode(this, config)\n\n    // create an empty modbus client\n    const ModbusRTU = require('modbus-serial')\n\n    const unlimitedListeners = 0\n    const minCommandDelayMilliseconds = 1\n    const defaultUnitId = 1\n    const defaultTcpUnitId = 0\n    const serialConnectionDelayTimeMS = 500\n    const timeoutTimeMS = 1000\n    const reconnectTimeMS = 2000\n    const logHintText = ' Get More About It By Logging'\n\n    this.clienttype = config.clienttype\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.bufferCommands = true\n    } else {\n      this.bufferCommands = config.bufferCommands\n    }\n\n    this.queueLogEnabled = config.queueLogEnabled\n    this.stateLogEnabled = config.stateLogEnabled\n\n    this.tcpHost = config.tcpHost\n    this.tcpPort = parseInt(config.tcpPort) || 502\n    this.tcpType = config.tcpType\n\n    this.serialPort = config.serialPort\n    this.serialBaudrate = config.serialBaudrate\n    this.serialDatabits = config.serialDatabits\n    this.serialStopbits = config.serialStopbits\n    this.serialParity = config.serialParity\n    this.serialType = config.serialType\n    this.serialConnectionDelay = parseInt(config.serialConnectionDelay) || serialConnectionDelayTimeMS\n    this.serialAsciiResponseStartDelimiter = config.serialAsciiResponseStartDelimiter\n\n    this.unit_id = parseInt(config.unit_id)\n    this.commandDelay = parseInt(config.commandDelay) || minCommandDelayMilliseconds\n    this.clientTimeout = parseInt(config.clientTimeout) || timeoutTimeMS\n    this.reconnectTimeout = parseInt(config.reconnectTimeout) || reconnectTimeMS\n    this.reconnectOnTimeout = config.reconnectOnTimeout\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.parallelUnitIdsAllowed = true\n    } else {\n      this.parallelUnitIdsAllowed = config.parallelUnitIdsAllowed\n    }\n\n    const node = this\n    node.isFirstInitOfConnection = true\n    node.closingModbus = false\n    node.client = null\n    node.bufferCommandList = new Map()\n    node.sendingAllowed = new Map()\n    node.unitSendingAllowed = []\n    node.messageAllowedStates = coreModbusClient.messagesAllowedStates\n    node.serverInfo = ''\n\n    node.stateMachine = null\n    node.stateService = null\n    node.stateMachine = coreModbusClient.createStateMachineService()\n    node.actualServiceState = node.stateMachine.initialState\n    node.actualServiceStateBefore = node.actualServiceState\n    node.stateService = coreModbusClient.startStateService(node.stateMachine)\n    node.reconnectTimeoutId = 0\n    node.serialSendingAllowed = false\n    node.internalDebugLog = internalDebugLog\n\n    coreModbusQueue.queueSerialLockCommand(node)\n\n    node.setDefaultUnitId = function () {\n      if (this.clienttype === 'tcp') {\n        node.unit_id = defaultTcpUnitId\n      } else {\n        node.unit_id = defaultUnitId\n      }\n    }\n\n    node.setUnitIdFromPayload = function (msg) {\n      const unitId = coreModbusClient.getActualUnitId(node, msg)\n      if (!coreModbusClient.checkUnitId(unitId, node.clienttype)) {\n        node.setDefaultUnitId()\n      }\n      node.client.setID(unitId)\n      msg.unitId = unitId\n    }\n\n    if (Number.isNaN(node.unit_id) || !coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n      node.setDefaultUnitId()\n    }\n\n    node.updateServerinfo = function () {\n      if (node.clienttype === 'tcp') {\n        node.serverInfo = ' TCP@' + node.tcpHost + ':' + node.tcpPort\n      } else {\n        node.serverInfo = ' Serial@' + node.serialPort + ':' + node.serialBaudrate + 'bit/s'\n      }\n      node.serverInfo += ' default Unit-Id: ' + node.unit_id\n    }\n\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose) {\n        node.warn('Client -> ' + logMessage + node.serverInfo)\n      }\n    }\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose) {\n        coreModbusClient.internalDebug('Client -> ' + logMessage + node.serverInfo)\n      }\n    }\n\n    function stateLog (logMessage) {\n      if (node.stateLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.queueLog = function (logMessage) {\n      if (node.bufferCommands && node.queueLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.stateService.subscribe(state => {\n      node.actualServiceStateBefore = node.actualServiceState\n      node.actualServiceState = state\n      stateLog(state.value)\n\n      if (!state.value || node.actualServiceState.value === undefined) {\n        // verboseWarn('fsm ignore invalid state')\n        return\n      }\n\n      if (node.actualServiceStateBefore.value === node.actualServiceState.value) {\n        // verboseWarn('fsm ignore equal state ' + node.actualServiceState.value + ' after ' + node.actualServiceStateBefore.value)\n        return\n      }\n\n      if (state.matches('init')) {\n        verboseWarn('fsm init state after ' + node.actualServiceStateBefore.value)\n        node.updateServerinfo()\n        coreModbusQueue.initQueue(node)\n        node.reconnectTimeoutId = 0\n\n        try {\n          if (node.isFirstInitOfConnection) {\n            node.isFirstInitOfConnection = false\n            verboseWarn('first fsm init in ' + serialConnectionDelayTimeMS + ' ms')\n            setTimeout(node.connectClient, serialConnectionDelayTimeMS)\n          } else {\n            verboseWarn('fsm init in ' + node.reconnectTimeout + ' ms')\n            setTimeout(node.connectClient, node.reconnectTimeout)\n          }\n        } catch (err) {\n          node.error(err, { payload: 'client connection error ' + logHintText })\n        }\n\n        node.emit('mbinit')\n      }\n\n      if (state.matches('connected')) {\n        verboseWarn('fsm connected after state ' + node.actualServiceStateBefore.value + logHintText)\n        coreModbusQueue.queueSerialUnlockCommand(node)\n        node.emit('mbconnected')\n      }\n\n      if (state.matches('activated')) {\n        node.emit('mbactive')\n        if (node.bufferCommands && !coreModbusQueue.checkQueuesAreEmpty(node)) {\n          node.stateService.send('QUEUE')\n        }\n      }\n\n      if (state.matches('queueing')) {\n        if (node.clienttype === 'tcp') {\n          node.stateService.send('SEND')\n        } else {\n          if (node.serialSendingAllowed) {\n            coreModbusQueue.queueSerialLockCommand(node)\n            node.stateService.send('SEND')\n          }\n        }\n      }\n\n      if (state.matches('sending')) {\n        setTimeout(() => {\n          coreModbusQueue.dequeueCommand(node)\n        }, node.commandDelay)\n        node.emit('mbqueue')\n      }\n\n      if (state.matches('opened')) {\n        coreModbusQueue.queueSerialUnlockCommand(node)\n        node.emit('mbopen')\n      }\n\n      if (state.matches('switch')) {\n        node.emit('mbswitch')\n        node.stateService.send('CLOSE')\n      }\n\n      if (state.matches('closed')) {\n        node.emit('mbclosed')\n        node.stateService.send('RECONNECT')\n      }\n\n      if (state.matches('stopped')) {\n        verboseWarn('stopped state without reconnecting')\n        node.emit('mbclosed')\n      }\n\n      if (state.matches('failed')) {\n        verboseWarn('fsm failed state after ' + node.actualServiceStateBefore.value + logHintText)\n        node.emit('mberror', 'Modbus Failure On State ' + node.actualServiceStateBefore.value + logHintText)\n        node.stateService.send('BREAK')\n      }\n\n      if (state.matches('broken')) {\n        verboseWarn('fsm broken state after ' + node.actualServiceStateBefore.value + logHintText)\n        node.emit('mbbroken', 'Modbus Broken On State ' + node.actualServiceStateBefore.value + logHintText)\n        if (node.reconnectOnTimeout) {\n          node.stateService.send('RECONNECT')\n        } else {\n          node.stateService.send('ACTIVATE')\n        }\n      }\n\n      if (state.matches('reconnecting')) {\n        verboseWarn('fsm reconnect state after ' + node.actualServiceStateBefore.value + logHintText)\n        coreModbusQueue.queueSerialLockCommand(node)\n        node.emit('mbreconnecting')\n        if (node.reconnectTimeout <= 0) {\n          node.reconnectTimeout = reconnectTimeMS\n        }\n        setTimeout(() => {\n          node.reconnectTimeoutId = 0\n          node.stateService.send('INIT')\n        }, node.reconnectTimeout)\n      }\n    })\n\n    node.connectClient = function () {\n      if (node.client) {\n        try {\n          node.client.close(function () {\n            verboseLog('connection closed')\n          })\n          verboseLog('connection close sent')\n        } catch (err) {\n          verboseLog(err.message)\n        }\n      }\n      node.client = null\n      node.client = new ModbusRTU()\n\n      if (!node.clientTimeout) {\n        node.clientTimeout = timeoutTimeMS\n      }\n\n      if (!node.reconnectTimeout) {\n        node.reconnectTimeout = reconnectTimeMS\n      }\n\n      if (node.clienttype === 'tcp') {\n        if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n          node.error(new Error('wrong unit-id (0..255)'), { payload: node.unit_id })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        switch (node.tcpType) {\n          case 'C701':\n            verboseLog('C701 port UDP bridge')\n            node.client.connectC701(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .then(node.setTCPConnected)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          case 'TELNET':\n            verboseLog('Telnet port')\n            node.client.connectTelnet(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          case 'TCP-RTU-BUFFERED':\n            verboseLog('TCP RTU buffered port')\n            node.client.connectTcpRTUBuffered(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          default:\n            verboseLog('TCP port')\n            node.client.connectTCP(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n        }\n      } else {\n        if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n          node.error(new Error('wrong unit-id serial (0..247)'), { payload: node.unit_id })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        if (!node.serialConnectionDelay) {\n          node.serialConnectionDelay = serialConnectionDelayTimeMS\n        }\n\n        if (!node.serialPort) {\n          node.error(new Error('wrong serial port'), { payload: node.serialPort })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        const serialPortOptions = {\n          baudRate: parseInt(node.serialBaudrate),\n          dataBits: parseInt(node.serialDatabits),\n          stopBits: parseInt(node.serialStopbits),\n          parity: node.serialParity,\n          autoOpen: false\n        }\n\n        switch (node.serialType) {\n          case 'ASCII':\n            verboseLog('ASCII port serial')\n            serialPortOptions.startOfSlaveFrameChar = parseInt(node.serialAsciiResponseStartDelimiter, 16)\n            verboseLog('Using response delimiter: 0x' + serialPortOptions.startOfSlaveFrameChar.toString(16))\n            node.client.connectAsciiSerial(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n          case 'RTU':\n            verboseLog('RTU port serial')\n            node.client.connectRTU(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n          default:\n            verboseLog('RTU buffered port serial')\n            node.client.connectRTUBuffered(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n        }\n      }\n    }\n\n    node.setTCPConnectionOptions = function () {\n      node.client.setID(node.unit_id)\n      node.client.setTimeout(node.clientTimeout)\n      node.stateService.send('CONNECT')\n    }\n\n    node.setTCPConnected = function () {\n      coreModbusClient.modbusSerialDebug('modbus tcp connected on ' + node.tcpHost)\n    }\n\n    node.setSerialConnectionOptions = function () {\n      node.stateService.send('OPENSERIAL')\n      setTimeout(node.openSerialClient, parseInt(node.serialConnectionDelay))\n    }\n\n    node.modbusErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + JSON.stringify(err))\n      }\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.stateService.send('FAILURE')\n      }\n    }\n\n    node.modbusTcpErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + JSON.stringify(err))\n      }\n\n      if ((err.errno && coreModbusClient.networkErrors.includes(err.errno)) ||\n      (err.code && coreModbusClient.networkErrors.includes(err.code))) {\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.modbusSerialErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + JSON.stringify(err))\n      }\n      node.stateService.send('BREAK')\n    }\n\n    node.openSerialClient = function () {\n      // some delay for windows\n      if (node.actualServiceState.value === 'opened') {\n        verboseLog('time to open Unit ' + node.unit_id)\n        coreModbusClient.modbusSerialDebug('modbus connection opened')\n        node.client.setID(node.unit_id)\n        node.client.setTimeout(parseInt(node.clientTimeout))\n        node.client._port.on('close', node.onModbusClose)\n        node.stateService.send('CONNECT')\n      } else {\n        verboseLog('wrong state on connect serial ' + node.actualServiceState.value)\n        coreModbusClient.modbusSerialDebug('modbus connection not opened state is %s', node.actualServiceState.value)\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.onModbusClose = function () {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      verboseWarn('Modbus closed port')\n      coreModbusClient.modbusSerialDebug('modbus closed port')\n      node.stateService.send('CLOSE')\n    }\n\n    node.on('readModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.messageAllowedStates.indexOf(state.value) === -1) {\n        cberr(new Error('Client Not Ready To Read At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.readModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued read msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.readModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.on('writeModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.messageAllowedStates.indexOf(state.value) === -1) {\n        cberr(new Error('Client Not Ready To Write At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.writeModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued write msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.writeModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.activateSending = function (msg) {\n      node.sendingAllowed.set(msg.queueUnitId, true)\n      coreModbusQueue.queueSerialUnlockCommand(node)\n\n      return new Promise(\n        function (resolve, reject) {\n          try {\n            if (node.bufferCommands) {\n              node.queueLog(JSON.stringify({\n                info: 'queue response activate sending',\n                queueLength: node.bufferCommandList.length,\n                sendingAllowed: node.sendingAllowed.get(msg.queueUnitId),\n                serialSendingAllowed: node.serialSendingAllowed,\n                queueUnitId: msg.queueUnitId\n              }))\n\n              if (coreModbusQueue.checkQueuesAreEmpty(node)) {\n                node.stateService.send('EMPTY')\n              }\n            }\n            resolve()\n          } catch (err) {\n            reject(err)\n          }\n        })\n    }\n\n    verboseLog('initialized')\n    node.setMaxListeners(unlimitedListeners)\n\n    node.on('reconnect', function () {\n      node.stateService.send('CLOSE')\n    })\n\n    node.on('dynamicReconnect', function (msg, cb, cberr) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        throw new Error('Message Or Payload Not Valid')\n      }\n\n      coreModbusClient.internalDebug('Dynamic Reconnect Parameters ' + JSON.stringify(msg.payload))\n      if (coreModbusClient.setNewNodeSettings(node, msg)) {\n        cb(msg)\n      } else {\n        cberr(new Error('Message Or Payload Not Valid'), msg)\n      }\n      coreModbusClient.internalDebug('Dynamic Reconnect Starts on actual state ' + node.actualServiceState.value)\n      node.stateService.send('SWITCH')\n    })\n\n    node.on('close', function (done) {\n      const nodeIdentifierName = node.name || node.id\n      node.closingModbus = true\n      verboseLog('stop fsm on close ' + nodeIdentifierName)\n      node.stateService.send('STOP')\n      verboseLog('close node ' + nodeIdentifierName)\n      node.internalDebugLog('close node ' + nodeIdentifierName)\n      node.removeAllListeners()\n      if (node.client) {\n        if (node.client.isOpen) {\n          node.client.close(function (err) {\n            if (err) {\n              verboseLog('Connection closed with error ' + nodeIdentifierName)\n            } else {\n              verboseLog('Connection closed well ' + nodeIdentifierName)\n            }\n            done()\n          })\n        } else {\n          verboseLog('connection was closed ' + nodeIdentifierName)\n          done()\n        }\n      } else {\n        verboseLog('Connection closed simple ' + nodeIdentifierName)\n        done()\n      }\n    })\n\n    // handle using as config node\n    node.registeredNodeList = {}\n\n    node.registerForModbus = function (clientUserNodeId) {\n      node.registeredNodeList[clientUserNodeId] = clientUserNodeId\n      if (Object.keys(node.registeredNodeList).length === 1) {\n        node.closingModbus = false\n        node.stateService.send('NEW')\n        node.stateService.send('INIT')\n      }\n      node.emit('mbregister', clientUserNodeId)\n    }\n\n    node.setStoppedState = function (clientUserNodeId, done) {\n      node.stateService.send('STOP')\n      node.emit('mbderegister', clientUserNodeId)\n      done()\n    }\n\n    node.closeConnectionWithoutRegisteredNodes = function (clientUserNodeId, done) {\n      if (Object.keys(node.registeredNodeList).length === 0) {\n        node.closingModbus = true\n        if (node.client && node.actualServiceState.value !== 'stopped') {\n          if (node.client.isOpen) {\n            node.client.close(function () {\n              node.setStoppedState(clientUserNodeId, done)\n            })\n          } else {\n            node.setStoppedState(clientUserNodeId, done)\n          }\n        } else {\n          node.setStoppedState(clientUserNodeId, done)\n        }\n      } else {\n        node.setStoppedState(clientUserNodeId, done)\n      }\n    }\n\n    node.deregisterForModbus = function (clientUserNodeId, done) {\n      try {\n        delete node.registeredNodeList[clientUserNodeId]\n        if (node.closingModbus) {\n          done()\n          node.emit('mbderegister', clientUserNodeId)\n        } else {\n          node.closeConnectionWithoutRegisteredNodes(clientUserNodeId, done)\n        }\n      } catch (err) {\n        verboseWarn(err.message + ' on de-register node ' + clientUserNodeId)\n        node.error(err)\n        done()\n      }\n    }\n  }\n\n  RED.nodes.registerType('modbus-client', ModbusClientNode)\n\n  RED.httpAdmin.get('/modbus/serial/ports', RED.auth.needsPermission('serial.read'), function (req, res) {\n    const SerialPort = require('serialport')\n    SerialPort.list().then(ports => {\n      res.json(ports)\n    }).catch(err => {\n      res.json([err.message])\n      coreModbusClient.internalDebug(err.message)\n    })\n  })\n}\n"]}