{"version":3,"sources":["modbus-queue-info.js"],"names":["module","exports","RED","install","mbBasics","require","coreModbusQueue","node","registerType","removeModbusQueueActionsFromNode","config","nodes","createNode","this","name","internalDebugLog","topic","unitid","parseInt","lowLowLevel","ModbusQueueInfo","highLevel","highHighLevel","lowLevel","updateOnAllUnitQueues","queueReadIntervalTime","updateOnAllQueueChanges","Map","queueReadInterval","unitsWithQueue","getNode","server","modbusClient","initUnitQueueStates","unit","registerForModbus","resetStates","unitWithQueue","get","lowLowLevelReached","lowLevelReached","highLevelReached","err","msg","highHighLevelReached","sendEmptyMsgOnFail","checkLowLevelReached","bufferCommandListLength","now","state","modbusClientName","payload","checkHighLevelReached","Date","id","warn","send","Error","getStatusSituationFillColor","fillColor","errorOnHighLevel","setNodeStatusByActivity","showStatusActivities","status","readFromQueue","updateStatusRrunning","bufferCommands","Promise","resolve","reject","bufferCommandList","length","checkQueueStates","readFromAllUnitQueues","eventCallback","on","registerModbusQueueActionsToNode","removeListener","setNodeStatusTo","queueEnabled","msgUnitId","resetQueue","unitId","errorProtocolMsg","queues","queue","queueOptions","allQueueData","verbose","infoText","lowlowLevel","msgQueueReset","shape","settings","fill","text","clearInterval","deregisterForModbus","done","setNodeDefaultStatus"],"mappings":"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","file":"../modbus-queue-info.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n\n/**\n * Modbus Read node.\n * @module NodeRedModbusRead\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n  const internalDebugLog = require('debug')('contribModbus:queue')\n\n  function ModbusQueueInfo (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.topic = config.topic\n    this.unitid = parseInt(config.unitid) || 1\n    this.lowLowLevel = parseInt(config.lowLowLevel)\n    this.lowLevel = parseInt(config.lowLevel)\n    this.highLevel = parseInt(config.highLevel)\n    this.highHighLevel = parseInt(config.highHighLevel)\n    this.errorOnHighLevel = config.errorOnHighLevel\n    this.queueReadIntervalTime = config.queueReadIntervalTime || 1000\n    this.showStatusActivities = config.showStatusActivities\n    this.updateOnAllQueueChanges = config.updateOnAllQueueChanges\n    this.updateOnAllUnitQueues = config.updateOnAllUnitQueues\n\n    this.internalDebugLog = internalDebugLog\n\n    const node = this\n    node.queueReadInterval = null\n    node.updateStatusRrunning = false\n    node.unitsWithQueue = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n\n    node.initUnitQueueStates = function () {\n      for (let unit = 0; unit < 256; unit += 1) {\n        node.unitsWithQueue.set(unit, {})\n        node.resetStates(unit)\n      }\n    }\n\n    node.resetStates = function (unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      unitWithQueue.lowLowLevelReached = true\n      unitWithQueue.lowLevelReached = false\n      unitWithQueue.highLevelReached = false\n      unitWithQueue.highHighLevelReached = false\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      mbBasics.logMsgError(node, err, msg)\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\n    }\n\n    node.initUnitQueueStates()\n\n    node.checkLowLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.lowLevelReached && bufferCommandListLength > node.lowLowLevel && bufferCommandListLength < node.lowLevel) {\n        unitWithQueue.lowLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'low level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name,\n          bufferCommandListLength: bufferCommandListLength\n        }\n        node.send(msg)\n      }\n    }\n\n    node.checkHighLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.highLevelReached &&\n        bufferCommandListLength > node.lowLevel &&\n        bufferCommandListLength > node.highLevel) {\n        unitWithQueue.highLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'high level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name || modbusClient.id,\n          highLevel: node.highLevel,\n          bufferCommandListLength: bufferCommandListLength\n        }\n\n        if (node.errorOnHighLevel) {\n          node.error(new Error('Queue High Level Reached'), msg)\n        } else {\n          node.warn(msg)\n        }\n\n        node.send(msg)\n      }\n    }\n\n    node.checkHighHighLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.highHighLevelReached &&\n        bufferCommandListLength > node.highLevel &&\n        bufferCommandListLength > node.highHighLevel) {\n        unitWithQueue.highHighLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'high high level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name || modbusClient.id,\n          highLevel: node.highLevel,\n          highHighLevel: node.highHighLevel,\n          bufferCommandListLength: bufferCommandListLength\n        }\n        node.error(new Error('Queue High High Level Reached'), msg)\n        node.send(msg)\n      }\n    }\n\n    node.getStatusSituationFillColor = function (unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      let fillColor = 'blue'\n\n      if (unitWithQueue.lowLevelReached) {\n        fillColor = 'green'\n      }\n\n      if (unitWithQueue.highLevelReached) {\n        if (node.errorOnHighLevel) {\n          fillColor = 'red'\n        } else {\n          fillColor = 'yellow'\n        }\n      }\n\n      if (unitWithQueue.highHighLevelReached) {\n        fillColor = 'red'\n      }\n\n      return fillColor\n    }\n\n    node.setNodeStatusByActivity = function (bufferCommandListLength, unit) {\n      if (node.showStatusActivities) {\n        node.status({\n          fill: node.getStatusSituationFillColor(node.unitid),\n          shape: 'ring',\n          text: (bufferCommandListLength) ? 'active unit ' + unit + ' queue items: ' + bufferCommandListLength : 'active (Unit-Id: ' + unit + ') empty'\n        })\n      }\n    }\n\n    node.readFromQueue = function () {\n      if (node.updateStatusRrunning) {\n        return\n      }\n      const unit = ((node.unitid < 1 || node.unitid > 255)) ? 1 : node.unitid\n      if (modbusClient.bufferCommands) {\n        return new Promise(\n          function (resolve, reject) {\n            try {\n              node.updateStatusRrunning = true\n              const bufferCommandListLength = modbusClient.bufferCommandList.get(unit).length\n              node.checkQueueStates(bufferCommandListLength, unit)\n              node.setNodeStatusByActivity(bufferCommandListLength, unit)\n              node.updateStatusRrunning = false\n              resolve()\n            } catch (err) {\n              node.updateStatusRrunning = false\n              reject(err)\n            }\n          })\n      } else {\n        if (node.showStatusActivities) {\n          node.setNodeStatusByActivity(null, unit)\n        }\n      }\n    }\n\n    node.checkQueueStates = function (bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.lowLowLevelReached && bufferCommandListLength < node.lowLowLevel) {\n        node.resetStates(unit)\n      }\n      node.checkLowLevelReached(node, bufferCommandListLength, unit)\n      node.checkHighLevelReached(node, bufferCommandListLength, unit)\n      node.checkHighHighLevelReached(node, bufferCommandListLength, unit)\n    }\n\n    node.readFromAllUnitQueues = function () {\n      if (node.updateStatusRrunning) {\n        return\n      }\n\n      if (modbusClient.bufferCommands) {\n        return new Promise(\n          function (resolve, reject) {\n            try {\n              node.updateStatusRrunning = true\n              let bufferCommandListLength = 0\n              for (let unit = 0; unit < 256; unit += 1) {\n                bufferCommandListLength = modbusClient.bufferCommandList.get(unit).length\n                if (!bufferCommandListLength) {\n                  continue\n                }\n                node.checkQueueStates(bufferCommandListLength, unit)\n              }\n              node.updateStatusRrunning = false\n              resolve()\n            } catch (err) {\n              node.updateStatusRrunning = false\n              reject(err)\n            }\n          })\n      }\n    }\n\n    node.registerModbusQueueActionsToNode = function (eventCallback) {\n      if (node.updateOnAllQueueChanges) { // much more CPU-Load on many parallel requests to the client\n        modbusClient.on('mbqueue', eventCallback) // en-queue\n      }\n      modbusClient.on('mbactive', eventCallback) // de-queue\n      modbusClient.on('mbinit', eventCallback)\n      modbusClient.on('mbconnected', eventCallback)\n      modbusClient.on('mberror', eventCallback)\n      modbusClient.on('mbclosed', eventCallback)\n      node.queueReadInterval = setInterval(eventCallback, node.queueReadIntervalTime)\n    }\n\n    node.removeModbusQueueActionsFromNode = function (eventCallback) {\n      modbusClient.removeListener('mbqueue', eventCallback)\n      modbusClient.removeListener('mbactive', eventCallback)\n      modbusClient.removeListener('mbinit', eventCallback)\n      modbusClient.removeListener('mbconnected', eventCallback)\n      modbusClient.removeListener('mberror', eventCallback)\n      modbusClient.removeListener('mbclosed', eventCallback)\n    }\n\n    if (node.updateOnAllUnitQueues) {\n      node.registerModbusQueueActionsToNode(node.readFromAllUnitQueues)\n      mbBasics.setNodeStatusTo('active for all queues', node)\n    } else {\n      node.registerModbusQueueActionsToNode(node.readFromQueue)\n    }\n\n    node.on('input', function (msg) {\n      let msgUnitId = node.unitid\n      msg.payload = {}\n      msg.payload.queueEnabled = modbusClient.bufferCommands\n\n      if (node.updateOnAllUnitQueues) {\n        msg.payload.allQueueData = true\n        msg.payload.queues = modbusClient.bufferCommandList\n      } else {\n        try {\n          if (msg.payload.resetQueue) {\n            msgUnitId = parseInt(msg.payload.unitId) || node.unitid\n          } else {\n            msgUnitId = parseInt(msg.payload) || node.unitid\n          }\n        } catch (err) {\n          node.errorProtocolMsg(err, msg)\n          msgUnitId = node.unitid\n        }\n        msg.payload.allQueueData = false\n        msg.payload.unitid = msgUnitId\n        msg.payload.queue = modbusClient.bufferCommandList.get(msgUnitId)\n      }\n\n      msg.payload.queueOptions = {\n        date: Date.now(),\n        state: 'queue request',\n        modbusClientName: modbusClient.name || modbusClient.id,\n        lowlowLevel: node.lowlowLevel,\n        unitId: msgUnitId,\n        lowLevel: node.lowLevel,\n        highLevel: node.highLevel,\n        highHighLevel: node.highHighLevel\n      }\n\n      const msgQueueReset = msg.payload.resetQueue || msg.resetQueue\n      if (msgQueueReset && modbusClient.bufferCommands) {\n        coreModbusQueue.initQueue(modbusClient)\n        if (RED.settings.verbose) {\n          const infoText = 'Init Queue By External Node'\n          modbusClient.warn(infoText)\n          internalDebugLog(infoText)\n        }\n        node.initUnitQueueStates()\n\n        if (node.showStatusActivities) {\n          node.status({\n            fill: 'blue',\n            shape: 'ring',\n            text: 'active empty unit queue'\n          })\n        }\n        msg.payload.queueOptions.state = 'queue reset done'\n      }\n\n      node.send(msg)\n    })\n\n    node.on('close', function (done) {\n      if (node.updateOnAllUnitQueues) {\n        node.removeModbusQueueActionsFromNode(node.readFromAllUnitQueues)\n      } else {\n        node.removeModbusQueueActionsFromNode(node.readFromQueue)\n      }\n      mbBasics.setNodeStatusTo('closed', node)\n      if (node.queueReadInterval) {\n        clearInterval(node.queueReadInterval)\n      }\n      node.queueReadInterval = null\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-queue-info', ModbusQueueInfo)\n}\n"]}